/* ----------------------------------------------------------------------------
 *         SAM Software Package License
 * ----------------------------------------------------------------------------
 * Copyright (c) 2014, Atmel Corporation
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the disclaimer below.
 *
 * Atmel's name may not be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ----------------------------------------------------------------------------
 */


/**
 *  \page getting-started Getting Started with sama5d3 Microcontrollers
 *
 *  \section Purpose
 *
 *  The Getting Started example will help new users get familiar with Atmel's
 *  sama5d3x microcontroller. This basic application shows the startup
 *  sequence of a chip and how to use its core peripherals.
 *
 *  \section Requirements
 *
 *  This package can be used with sama5d3 xplained board.
 *
 *  \section Description
 *
 *  The demonstration program makes two LEDs on the board blink at a fixed rate.
 *  This rate is generated by using Time tick timer. The blinking can be stopped
 *  using two buttons (one for each LED). If there is no enough buttons on board, please
 *  type "1" or "2" in the terminal application on PC to control the LEDs
 *  instead.
 *
 *  \section Usage
 *
 *  -# Build the program and download it inside the xplained board. Please
 *     refer to the
 *     <a href="http://www.atmel.com/dyn/resources/prod_documents/6421B.pdf">
 *     SAM-BA User Guide</a>, the
 *     <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6310.pdf">
 *     GNU-Based Software Development</a>
 *     application note or to the
 *     <a href="ftp://ftp.iar.se/WWWfiles/arm/Guides/EWARM_UserGuide.ENU.pdf">
 *     IAR EWARM User Guide</a>,
 *     depending on your chosen solution.
 *  -# On the computer, open and configure a terminal application
 *     (e.g. HyperTerminal on Microsoft Windows) with these settings:
 *    - 115200 bauds
 *    - 8 bits of data
 *    - No parity
 *    - 1 stop bit
 *    - No flow control
 *  -# Start the application.
 *  -# Two LEDs should start blinking on the board. In the terminal window, the
 *     following text should appear (values depend on the board and chip used):
 *     \code
 *      -- Getting Started Example xxx --
 *      -- SAMxxxxx-xx
 *      -- Compiled: xxx xx xxxx xx:xx:xx --
 *     \endcode
 *  -# Pressing and release button 1 or type "1" in the terminal application on
 *     PC should make the first LED stop & restart blinking.
 *     Pressing and release button 2 or type "1" in the terminal application on
 *     PC should make the other LED stop & restart blinking.
 *
 *  \section References
 *  - getting-started/main.c
 *  - pio.h
 *  - pio_it.h
 *  - led.h
 *  - trace.h
 */

/** \file
 *
 *  This file contains all the specific code for the getting-started example.
 *
 */

/*----------------------------------------------------------------------------
 *        Headers
 *----------------------------------------------------------------------------*/

#include "board.h"

#include <stdbool.h>
#include <stdio.h>

/*----------------------------------------------------------------------------
 *        Local definitions
 *----------------------------------------------------------------------------*/

#define NO_PUSHBUTTON

/** IRQ priority for PIO (The lower the value, the greater the priority) */
#define IRQ_PRIOR_PIO    0

/** LED0 blink time, LED1 blink half this time, in ms */
#define BLINK_PERIOD        1000

/** Delay for pushbutton debouncing (in milliseconds). */
#define DEBOUNCE_TIME       500

/*----------------------------------------------------------------------------
 *        Local variables
 *----------------------------------------------------------------------------*/

#ifndef NO_PUSHBUTTON
/** Pushbutton \#1 pin instance. */
const Pin pinPB1 = PIN_PUSHBUTTON_1 ;
/** Pushbutton \#1 pin instance. */
const Pin pinPB2 = PIN_PUSHBUTTON_2 ;
#endif

/** LED0 blinking control. */
volatile bool bLed0Active = true ;

/** LED1 blinking control. */
volatile bool bLed1Active = true ;

/** Global timestamp in milliseconds since start of application */
volatile uint32_t dwTimeStamp = 0;

/*----------------------------------------------------------------------------
 *        Local functions
 *----------------------------------------------------------------------------*/

/**
 *  \brief Process Buttons Events
 *
 *  Change active states of LEDs when corresponding button events happened.
 */
static void ProcessButtonEvt( uint8_t ucButton )
{
    if ( ucButton == 0 )
    {
        bLed0Active = !bLed0Active ;
        if ( !bLed0Active )
        {
            LED_Clear( 0 );
        }
    }
    else
    {
        bLed1Active = !bLed1Active ;

        /* Enable LED#2 and TC if they were disabled */
        if ( bLed1Active )
        {
            LED_Set( 1 );
            TC_Start( TC0, 0 );
        }
        /* Disable LED#2 and TC if they were enabled */
        else
        {
            LED_Clear( 1 );
            TC_Stop( TC0, 0 );
        }
    }
}

#ifndef NO_PUSHBUTTON
/**
 *  \brief Handler for Button 1 rising edge interrupt.
 *
 *  Handle process led1 status change.
 */
static void _Button1_Handler( const Pin* pin )
{
    pin = pin;
    ProcessButtonEvt( 0 ) ;
}

/**
 *  \brief Handler for Button 2 falling edge interrupt.
 *
 *  Handle process led2 status change.
 */
static void _Button2_Handler( const Pin* pin )
{
    pin = pin;
    ProcessButtonEvt( 1 ) ;
}
#else
/**
 *  \brief Handler for DBGU input.
 *
 *  Handle process LED1 or LED2 status change.
 */
static void _DBGU_Handler( void )
{
    uint8_t key;
    if ( !DBGU_IsRxReady( ) ) return ;
    key = DBGU_GetChar( ) ;
    switch ( key )
    {
        case '1': case '2':
            ProcessButtonEvt( key - '1' ) ;
        break;
    }
}
#endif

/**
 *  \brief Handler for PIT interrupt.
 */
static void _Pit_Handler( void )
{
    uint32_t status;

    /* Read the PIT status register */
    status = PIT_GetStatus() & PIT_SR_PITS;
    if (status != 0) {
        /* 1 = The Periodic Interval timer has reached PIV since the last read of PIT_PIVR.
            Read the PIVR to acknowledge interrupt and get number of ticks
            Returns the number of occurrences of periodic intervals since the last read of PIT_PIVR. */
        dwTimeStamp += (PIT_GetPIVR() >> 20);
    }
}

/**
 *  \brief Handler for Sysc interrupts.
 */
void _Sysc_Handler( void );
void _Sysc_Handler( void )
{
    _Pit_Handler( ) ;
  #ifdef NO_PUSHBUTTON
    _DBGU_Handler( ) ;
  #endif
}

/**
 *  \brief Configure the periodic interval timer (PIT) to generate an interrupt every
 *  interrupt every millisecond
 */
static void ConfigurePit(void)
{
    PMC->PMC_PCER0 = 1 << ID_PIT;
   /* Initialize the PIT to the desired frequency */
    PIT_Init(BLINK_PERIOD, BOARD_MCK / 1000000);
    /* Configure interrupt on PIT */
    IRQ_ConfigureIT(ID_PIT, 0, _Sysc_Handler);
    IRQ_EnableIT(ID_PIT);
    PIT_EnableIT();
    /* Enable the pit */
    PIT_Enable();
}

#ifndef NO_PUSHBUTTON
/**
 *  \brief Configure the Pushbuttons
 *
 *  Configure the PIO as inputs and generate corresponding interrupt when
 *  pressed or released.
 */
static void _ConfigureButtons( void )
{
    /* Configure pios as inputs. */
    PIO_Configure( &pinPB1, 1 ) ;
    PIO_Configure( &pinPB2, 1 ) ;

    /* Adjust pio debounce filter patameters, uses 10 Hz filter. */
    PIO_SetDebounceFilter( &pinPB1, 10 ) ;
    PIO_SetDebounceFilter( &pinPB1, 10 ) ;

    /* Enable PIO controller IRQs. */
    PIO_InitializeInterrupts(0);
    /* Initialize pios interrupt handlers, see PIO definition in board.h. */
    PIO_ConfigureIt(&pinPB1, (void (*)(const Pin *))_Button1_Handler);
    PIO_ConfigureIt(&pinPB2, (void (*)(const Pin *))_Button2_Handler);

    /* Enable PIO line interrupts. */
    PIO_EnableIt( &pinPB1 ) ;
    PIO_EnableIt( &pinPB2 ) ;
}
#endif

/**
 *  \brief Configure LEDs
 *
 *  Configures LEDs \#1 and \#2 (cleared by default).
 */
static void _ConfigureLeds( void )
{
    LED_Configure( 0 ) ;
    LED_Configure( 1 ) ;
}

/**
 *  Interrupt handler for TC0 interrupt. Toggles the state of LED\#2.
 */
static void TC0_IrqHandler( void )
{
    volatile uint32_t dummy;
    /* Clear status bit to acknowledge interrupt */
    dummy = TC0->TC_CHANNEL[ 0 ].TC_SR ;

    /** Toggle LED state. */
    LED_Toggle( 1 ) ;
    printf( "2 " ) ;
}

/**
 *  Configure Timer Counter 0 to generate an interrupt every 250ms.
 */
static void _ConfigureTc( void )
{
    uint32_t div;
    uint32_t tcclks;

    /** Enable peripheral clock. */
    PMC->PMC_PCER0 = 1 << ID_TC0;

    /** Configure TC for a 4Hz frequency and trigger on RC compare. */
    TC_FindMckDivisor( 4, BOARD_MCK, &div, &tcclks, BOARD_MCK );
    TC_Configure( TC0, 0, tcclks | TC_CMR_CPCTRG );
    TC0->TC_CHANNEL[ 0 ].TC_RC = ( BOARD_MCK / div ) / 4;

    /* Configure and enable interrupt on RC compare */
    IRQ_ConfigureIT(ID_TC0, 0, TC0_IrqHandler);
    TC0->TC_CHANNEL[ 0 ].TC_IER = TC_IER_CPCS;
    IRQ_EnableIT(ID_TC0);

    /** Start the counter if LED1 is enabled. */
    if ( bLed1Active )
    {
        TC_Start( TC0, 0 );
    }
}

/**
 *  Waits for the given number of milliseconds (using the dwTimeStamp generated
 *  by the SAM3's microcontrollers's system tick).
 *  \param delay  Delay to wait for, in milliseconds.
 */
static void _Wait( unsigned long delay )
{
    volatile uint32_t start = dwTimeStamp;
    uint32_t elapsed;
    do {
        elapsed = dwTimeStamp;
        elapsed -= start;
    }
    while (elapsed < delay);
}

/*----------------------------------------------------------------------------
 *        Global functions
 *----------------------------------------------------------------------------*/

/**
 *  \brief getting-started Application entry point.
 *
 *  \return Unused (ANSI-C compatibility).
 */
int atmel_main( void );
int atmel_main( void )
{
    /* Disable watchdog */
    WDT_Disable( WDT ) ;
#if defined (ddram)
    MMU_Initialize((uint32_t *)0x30C000);
    CP15_EnableMMU();
    CP15_EnableDcache();
    CP15_EnableIcache();
#endif

    /* Output example information */
    printf( "-- Getting Started Example %s --\n\r", SOFTPACK_VERSION ) ;
    printf( "-- %s\n\r", BOARD_NAME ) ;
    printf( "-- Compiled: %s %s --\n\r", __DATE__, __TIME__ ) ;

    /* Configure PIT. */
    printf( "Configure PIT \n\r" ) ;
//__asm volatile( "cpsid i" );
    ConfigurePit() ;

    /* PIO configuration for LEDs and Buttons. */
    PIO_InitializeInterrupts( IRQ_PRIOR_PIO ) ;

    printf( "Configure TC.\n\r" );
    _ConfigureTc() ;

    printf( "Configure LED PIOs.\n\r" ) ;
    _ConfigureLeds() ;

#ifndef NO_PUSHBUTTON
    printf( "Configure buttons with debouncing.\n\r" ) ;
    _ConfigureButtons() ;
    printf( "Press USRBP1 to Start/Stop the blue LED D1 blinking.\n\r" ) ;
    printf( "Press USRBP2 to Start/Stop the red LED D2 blinking.\n\r" ) ;

#else
    printf( "No push buttons, uses DBG key 1 & 2 instead.\n\r" ) ;
    printf( "Press 1 to Start/Stop the blue LED D1 blinking.\n\r" ) ;
    printf( "Press 2 to Start/Stop the red LED D2 blinking.\n\r" ) ;

#endif

    while ( 1 )
    {
        /* Wait for LED to be active */
        while( !bLed0Active );

        /* Toggle LED state if active */
        if ( bLed0Active )
        {
            LED_Toggle( 0 );
            printf( "1 " );
        }

        /* Wait for 500ms */
        _Wait(500);
    }
}
